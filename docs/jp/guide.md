# Wire ユーザーガイド

## 基本

Wireには2つのコア概念があります: プロバイダとインジェクタです。

### プロバイダの定義

Wireの主要なメカニズムは**プロバイダ**です: 値を生成できる関数です。これらの関数は通常のGoコードです。

```go
package foobarbaz

type Foo struct {
    X int
}

// ProvideFoo は Foo を返します。
func ProvideFoo() Foo {
    return Foo{X: 42}
}
```

プロバイダ関数は、通常の関数と同様に、他のパッケージから使用するためにエクスポートされている必要があります。

プロバイダはパラメータで依存関係を指定できます:

```go
package foobarbaz

// ...

type Bar struct {
    X int
}

// ProvideBar は Bar を返します: 負の Foo です。
func ProvideBar(foo Foo) Bar {
    return Bar{X: -foo.X}
}
```

プロバイダはエラーも返すことができます:

```go
package foobarbaz

import (
    "context"
    "errors"
)

// ...

type Baz struct {
    X int
}

// ProvideBaz は Bar がゼロでない場合に値を返します。
func ProvideBaz(ctx context.Context, bar Bar) (Baz, error) {
    if bar.X == 0 {
        return Baz{}, errors.New("cannot provide baz when bar is zero")
    }
    return Baz{X: bar.X}, nil
}
```

プロバイダは**プロバイダセット**にグループ化できます。これは、複数のプロバイダが頻繁に一緒に使用される場合に便利です。これらのプロバイダを`SuperSet`という新しいセットに追加するには、`wire.NewSet`関数を使用します:

```go
package foobarbaz

import (
    // ...
    "github.com/google/wire"
)

// ...

var SuperSet = wire.NewSet(ProvideFoo, ProvideBar, ProvideBaz)
```

他のプロバイダセットをプロバイダセットに追加することもできます。

```go
package foobarbaz

import (
    // ...
    "example.com/some/other/pkg"
)

// ...

var MegaSet = wire.NewSet(SuperSet, pkg.OtherSet)
```

### インジェクタ

アプリケーションは、これらのプロバイダを**インジェクタ**で結び付けます: プロバイダを依存関係の順序で呼び出す関数です。Wireでは、インジェクタのシグネチャを書き、その後Wireが関数本体を生成します。

インジェクタは、本体が`wire.Build`への呼び出しである関数宣言を記述することで宣言されます。戻り値は正しい型である限り、その内容は重要ではありません。値自体は生成されたコードでは無視されます。上記のプロバイダが`example.com/foobarbaz`というパッケージで定義されているとしましょう。以下は`Baz`を取得するためのインジェクタを宣言します:

```go
// +build wireinject
// ビルドタグは、最終ビルドでスタブがビルドされないようにします。

package main

import (
    "context"

    "github.com/google/wire"
    "example.com/foobarbaz"
)

func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
    wire.Build(foobarbaz.MegaSet)
    return foobarbaz.Baz{}, nil
}
```

プロバイダと同様に、インジェクタは入力でパラメータ化でき(それがプロバイダに送信されます)、エラーを返すことができます。`wire.Build`への引数は`wire.NewSet`と同じです: それらはプロバイダセットを形成します。これは、そのインジェクタのコード生成中に使用されるプロバイダセットです。

インジェクタを含むファイルで見つかった非インジェクタ宣言は、生成されたファイルにコピーされます。

パッケージディレクトリでWireを呼び出すことで、インジェクタを生成できます:

```shell
wire
```

Wireは、次のような`wire_gen.go`というファイルにインジェクタの実装を生成します:

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//+build !wireinject

package main

import (
    "example.com/foobarbaz"
)

func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
    foo := foobarbaz.ProvideFoo()
    bar := foobarbaz.ProvideBar(foo)
    baz, err := foobarbaz.ProvideBaz(ctx, bar)
    if err != nil {
        return foobarbaz.Baz{}, err
    }
    return baz, nil
}
```

ご覧のように、出力は開発者が自分で書くものに非常に近いです。さらに、実行時にWireへの依存はほとんどありません: 書かれたコードはすべて通常のGoコードであり、Wireなしで使用できます。

`wire_gen.go`が作成されたら、[`go generate`]を実行することで再生成できます。

[`go generate`]: https://blog.golang.org/generate

## 高度な機能

以下の機能はすべて、プロバイダとインジェクタの概念の上に構築されています。

### インターフェースのバインディング

多くの場合、依存性注入はインターフェースの具体的な実装をバインドするために使用されます。Wireは[型の同一性][]を介して入力を出力に一致させるため、インターフェース型を返すプロバイダを作成する傾向があるかもしれません。しかし、Goのベストプラクティスは[具象型を返す][]ことであるため、これは慣用的ではありません。代わりに、プロバイダセットでインターフェースバインディングを宣言できます:

```go
type Fooer interface {
    Foo() string
}

type MyFooer string

func (b *MyFooer) Foo() string {
    return string(*b)
}

func provideMyFooer() *MyFooer {
    b := new(MyFooer)
    *b = "Hello, World!"
    return b
}

type Bar string

func provideBar(f Fooer) string {
    // f は *MyFooer になります。
    return f.Foo()
}

var Set = wire.NewSet(
    provideMyFooer,
    wire.Bind(new(Fooer), new(*MyFooer)),
    provideBar)
```

`wire.Bind`の最初の引数は、望ましいインターフェース型の値へのポインタで、2番目の引数は、インターフェースを実装する型の値へのポインタです。インターフェースバインディングを含むセットには、同じセット内に具象型を提供するプロバイダも必要です。

[型の同一性]: https://golang.org/ref/spec#Type_identity
[具象型を返す]: https://github.com/golang/go/wiki/CodeReviewComments#interfaces

### 構造体プロバイダ

構造体は、提供された型を使用して構築できます。`wire.Struct`関数を使用して構造体型を構築し、どのフィールドを注入すべきかをインジェクタに伝えます。インジェクタは、各フィールドの型のプロバイダを使用して各フィールドを埋めます。結果として得られる構造体型`S`に対して、`wire.Struct`は`S`と`*S`の両方を提供します。例えば、以下のプロバイダがあるとします:

```go
type Foo int
type Bar int

func ProvideFoo() Foo {/* ... */}

func ProvideBar() Bar {/* ... */}

type FooBar struct {
    MyFoo Foo
    MyBar Bar
}

var Set = wire.NewSet(
    ProvideFoo,
    ProvideBar,
    wire.Struct(new(FooBar), "MyFoo", "MyBar"))
```

`FooBar`用に生成されたインジェクタは次のようになります:

```go
func injectFooBar() FooBar {
    foo := ProvideFoo()
    bar := ProvideBar()
    fooBar := FooBar{
        MyFoo: foo,
        MyBar: bar,
    }
    return fooBar
}
```

`wire.Struct`の最初の引数は、望ましい構造体型へのポインタで、後続の引数は注入されるフィールドの名前です。特別な文字列`"*"`をショートカットとして使用して、すべてのフィールドを注入するようインジェクタに指示できます。したがって、`wire.Struct(new(FooBar), "*")`は上記と同じ結果を生成します。

上記の例では、`"MyFoo"`のみを注入するように指定するには、`Set`を次のように変更します:

```go
var Set = wire.NewSet(
    ProvideFoo,
    wire.Struct(new(FooBar), "MyFoo"))
```

その場合、`FooBar`用に生成されたインジェクタは次のようになります:

```go
func injectFooBar() FooBar {
    foo := ProvideFoo()
    fooBar := FooBar{
        MyFoo: foo,
    }
    return fooBar
}
```

インジェクタが`FooBar`の代わりに`*FooBar`を返す場合、生成されたインジェクタは次のようになります:

```go
func injectFooBar() *FooBar {
    foo := ProvideFoo()
    fooBar := &FooBar{
        MyFoo: foo,
    }
    return fooBar
}
```

特定のフィールドがインジェクタによって埋められるのを防ぐと便利な場合があります、特に`*`を`wire.Struct`に渡す場合です。フィールドに`` `wire:"-"` ``タグを付けることで、Wireにそのようなフィールドを無視させることができます。例えば:

```go
type Foo struct {
    mu sync.Mutex `wire:"-"`
    Bar Bar
}
```

`wire.Struct(new(Foo), "*")`を使用して`Foo`型を提供すると、Wireは自動的に`mu`フィールドを省略します。さらに、`wire.Struct(new(Foo), "mu")`のように、防止されたフィールドを明示的に指定するとエラーになります。

### 値のバインディング

時折、基本的な値(通常は`nil`)を型にバインドすると便利です。インジェクタを使い捨てのプロバイダ関数に依存させる代わりに、値式をプロバイダセットに追加できます。

```go
type Foo struct {
    X int
}

func injectFoo() Foo {
    wire.Build(wire.Value(Foo{X: 42}))
    return Foo{}
}
```

生成されたインジェクタは次のようになります:

```go
func injectFoo() Foo {
    foo := _wireFooValue
    return foo
}

var (
    _wireFooValue = Foo{X: 42}
)
```

式はインジェクタのパッケージにコピーされることに注意することが重要です。変数への参照は、インジェクタパッケージの初期化中に評価されます。式が関数を呼び出したり、チャネルから受信したりする場合、Wireはエラーを出力します。

インターフェース値の場合は、`InterfaceValue`を使用します:

```go
func injectReader() io.Reader {
    wire.Build(wire.InterfaceValue(new(io.Reader), os.Stdin))
    return nil
}
```

### 構造体のフィールドをプロバイダとして使用する

時々、ユーザーが必要とするプロバイダは構造体のいくつかのフィールドです。以下の例で`getS`のようなプロバイダを書いて構造体フィールドを提供される型に昇格させている場合:

```go
type Foo struct {
    S string
    N int
    F float64
}

func getS(foo Foo) string {
    // 悪い例！ 代わりに wire.FieldsOf を使用してください。
    return foo.S
}

func provideFoo() Foo {
    return Foo{ S: "Hello, World!", N: 1, F: 3.14 }
}

func injectedMessage() string {
    wire.Build(
        provideFoo,
        getS)
    return ""
}
```

代わりに`wire.FieldsOf`を使用して、`getS`を書かずにこれらのフィールドを直接使用できます:

```go
func injectedMessage() string {
    wire.Build(
        provideFoo,
        wire.FieldsOf(new(Foo), "S"))
    return ""
}
```

生成されたインジェクタは次のようになります:

```go
func injectedMessage() string {
    foo := provideFoo()
    string2 := foo.S
    return string2
}
```

`wire.FieldsOf`関数には、好きなだけフィールド名を追加できます。与えられたフィールド型`T`に対して、`FieldsOf`は少なくとも`T`を提供します。構造体の引数が構造体へのポインタである場合、`FieldsOf`は`*T`も提供します。

### クリーンアップ関数

プロバイダがクリーンアップが必要なリソース(ファイルのクローズなど)を作成する場合、リソースをクリーンアップするためのクロージャを返すことができます。インジェクタはこれを使用して、集約されたクリーンアップ関数を呼び出し元に返すか、インジェクタの実装で後で呼び出されたプロバイダがエラーを返した場合にリソースをクリーンアップします。

```go
func provideFile(log Logger, path Path) (*os.File, func(), error) {
    f, err := os.Open(string(path))
    if err != nil {
        return nil, nil, err
    }
    cleanup := func() {
        if err := f.Close(); err != nil {
            log.Log(err)
        }
    }
    return f, cleanup, nil
}
```

クリーンアップ関数は、プロバイダの入力のクリーンアップ関数の前に呼び出されることが保証されており、シグネチャ`func()`を持つ必要があります。

### 代替インジェクタ構文

インジェクタ関数宣言の最後に`return foobarbaz.Foo{}, nil`と書くのに疲れた場合は、代わりに`panic`を使用してより簡潔に書くことができます:

```go
func injectFoo() Foo {
    panic(wire.Build(/* ... */))
}
```
