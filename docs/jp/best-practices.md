# ベストプラクティス

以下は、Wireを使用するために推奨するプラクティスです。このリストは時間とともに増えていきます。

## 型の区別

`string`のような一般的な型を注入する必要がある場合は、他のプロバイダとの競合を避けるために新しい文字列型を作成してください。例えば:

```go
type MySQLConnectionString string
```

## オプション構造体

多くの依存関係を含むプロバイダ関数は、オプション構造体と関数をペアにできます。

```go
type Options struct {
    // Messages は推奨される挨拶のセットです。
    Messages []Message
    // Writer は挨拶を送信する場所です。nil は標準出力に送信します。
    Writer io.Writer
}

func NewGreeter(ctx context.Context, opts *Options) (*Greeter, error) {
    // ...
}

var GreeterSet = wire.NewSet(wire.Struct(new(Options), "*"), NewGreeter)
```

## ライブラリのプロバイダセット

ライブラリで使用するためのプロバイダセットを作成する場合、互換性を壊さずに行える変更は次のとおりです:

-   プロバイダセットが特定の出力を提供するために使用するプロバイダを変更できますが、プロバイダセットに新しい入力を導入しない場合に限ります。入力を削除することはできます。ただし、既存のインジェクタは再生成されるまで古いプロバイダを使用することに注意してください。
-   新しい出力型をプロバイダセットに導入できますが、その型自体が新しく追加された場合のみです。型が新しくない場合、一部のインジェクタが既に出力型を含んでいる可能性があり、これにより競合が発生します。

他のすべての変更は安全ではありません。これには以下が含まれます:

-   プロバイダセットで新しい入力を要求する。
-   プロバイダセットから出力型を削除する。
-   既存の出力型をプロバイダセットに追加する。

これらの破壊的な変更のいずれかを行う代わりに、新しいプロバイダセットを追加することを検討してください。

例として、次のようなプロバイダセットがある場合:

```go
var GreeterSet = wire.NewSet(NewStdoutGreeter)

func DefaultGreeter(ctx context.Context) *Greeter {
    // ...
}

func NewStdoutGreeter(ctx context.Context, msgs []Message) *Greeter {
    // ...
}

func NewGreeter(ctx context.Context, w io.Writer, msgs []Message) (*Greeter, error) {
    // ...
}
```

次のことができます:

-   `GreeterSet`で`NewStdoutGreeter`の代わりに`DefaultGreeter`を使用する。
-   新しい型`T`を作成し、`T`のプロバイダを`GreeterSet`に追加できますが、`T`がプロバイダが追加されるのと同じコミット/リリースで導入される場合に限ります。

次のことはできません:

-   `GreeterSet`で`NewStdoutGreeter`の代わりに`NewGreeter`を使用する。これは、入力型(`io.Writer`)を追加し、インジェクタが`error`を返す必要があるため、以前は`*Greeter`のプロバイダがこれを必要としなかった場合です。
-   `GreeterSet`から`NewStdoutGreeter`を削除する。`*Greeter`に依存するインジェクタは壊れます。
-   `io.Writer`のプロバイダを`GreeterSet`に追加する。インジェクタはすでに`io.Writer`のプロバイダを持っている可能性があり、これと競合する可能性があります。

そのため、ライブラリプロバイダセットの出力型は慎重に選択する必要があります。一般的に、ライブラリでは小さなプロバイダセットを優先してください。例えば、ライブラリプロバイダセットには、単一のプロバイダ関数と、戻り値の型が実装するインターフェースへの`wire.Bind`が含まれることが一般的です。より大きなプロバイダセットを避けることで、アプリケーションが競合に遭遇する可能性が低くなります。例えば、あなたのライブラリがWebサービス用のクライアントを提供しているとします。ライブラリのクライアント用のプロバイダセットに`*http.Client`のプロバイダをバンドルするのは魅力的かもしれませんが、すべてのライブラリが同じことをすると競合が発生します。代わりに、ライブラリのプロバイダセットにはAPIクライアントのプロバイダのみを含め、`*http.Client`をプロバイダセットの入力にする必要があります。

## モック

モックされた依存関係を持つ注入されたアプリを作成するには、2つのアプローチがあります。両方のアプローチの例は[こちら](https://github.com/google/wire/tree/master/internal/wire/testdata/ExampleWithMocks/foo)で示されています。

### アプローチA: モックをインジェクタに渡す

すべてのモックを引数として受け取るテスト専用のインジェクタを作成します。引数の型は、モックがモックしているインターフェース型である必要があります。`wire.Build`は、競合を作成せずにモックされた依存関係のプロバイダを含めることができないため、プロバイダセットを使用している場合は、モックされた型を含まないものを定義する必要があります。

### アプローチB: インジェクタからモックを返す

アプリとモックしたいすべての依存関係を含む新しい構造体を作成します。この構造体を返すテスト専用のインジェクタを作成し、具象モック型のプロバイダを提供し、`wire.Bind`を使用して具象モック型を適切なインターフェースを満たすために使用すべきことをWireに伝えます。
