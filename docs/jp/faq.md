# よくある質問

## Wireは他のGo依存性注入ツールとどう違いますか?

[dig][]や[facebookgo/inject][]のような他のGo用依存性注入ツールは、リフレクションに基づいています。Wireはコードジェネレータとして実行されるため、インジェクタは実行時ライブラリへの呼び出しなしで動作します。これにより、初期化の容易な内省と、[guru][]のようなツール向けの正確なクロスリファレンスが可能になります。

[dig]: https://github.com/uber-go/dig
[facebookgo/inject]: https://github.com/facebookgo/inject
[guru]: https://golang.org/s/using-guru

## Wireは他の非Go依存性注入ツール(Dagger 2など)とどう違いますか?

Wireのアプローチは[Dagger 2][]にインスパイアされました。ただし、Wireの目的は他の言語の依存性注入ツールをエミュレートすることではありません: 設計空間と要件はかなり異なります。例えば、Goコンパイラは、Javaのアノテーション処理メカニズムのようなものをサポートしていません。言語とそのイディオムの違いは、必然的にプリミティブとAPIの異なるアプローチを必要とします。

[Dagger 2]: https://google.github.io/dagger/

## なぜプロバイダセットやインジェクタを作成するために疑似関数を使用するのですか?

初期のプロトタイプでは、Wireのディレクティブは特別にフォーマットされたコメントでした。これは一見魅力的に見えました。これはコンパイル時や実行時への影響がないことを意味していたからです。しかし、この非構造化アプローチは、Wire用に書かれていない他のツールには不透明になります。[`gorename`][]や[guru][]のようなツールは、特別にWireのコメントフォーマットを理解するように変更されない限り、コメント内に存在する識別子への参照を認識できません。参照をノーオペレーション関数呼び出しに移動することで、Wireは他のGoツールとシームレスに相互運用できます。

[`gorename`]: https://godoc.org/golang.org/x/tools/cmd/gorename

## 依存関係グラフに同じ型の2つの依存関係がある場合はどうなりますか?

これは、`string`のような一般的な型で最も頻繁に現れます。この問題の例は次のとおりです:

```go
type Foo struct { /* ... */ }
type Bar struct { /* ... */ }

func newFoo1() *Foo { /* ... */ }
func newFoo2() *Foo { /* ... */ }
func newBar(foo1 *Foo, foo2 *Foo) *Bar { /* ... */ }

func inject() *Bar {
	// エラー! *Foo の複数のプロバイダ。
	wire.Build(newFoo1, newFoo2, newBar)
	return nil
}
```

Wireは、`wire.Build`に提示されたプロバイダの推移的閉包に1つの型に対する複数のプロバイダが存在することを許可しません。これは通常はミスだからです。同じ型の複数の依存関係が必要な正当なケースの場合、この他の依存関係を呼び出すために新しい型を発明する必要があります。例えば、OAuth認証情報を接続先のサービスにちなんで名前を付けることができます。適切な異なる型ができたら、Wireを介して配管する際に型をラップおよびアンラップできます。上記の例を続けると:

```go
type OtherFoo Foo

func newOtherFoo() *OtherFoo {
	// 元のプロバイダを呼び出し...
	foo := newFoo2()
	// ...それを新しい型に変換します。
	return (*OtherFoo)(foo)
}

func provideBar(foo1 *Foo, otherFoo *OtherFoo) *Bar {
	// 新しい型をアンラップされた型に変換し...
	foo2 := (*Foo)(otherFoo)
	// ...それを使用して元のプロバイダを呼び出します。
	return newBar(foo1, foo2)
}

func inject() *Bar {
	wire.Build(newFoo1, newOtherFoo, provideBar)
	return nil
}
```

## なぜWireは同じプロバイダを複数回含めることを禁止するのですか?

Wireがこれを禁止するのは、同じ型に対して複数のプロバイダを指定することがエラーであるという原則と一貫性を保つためです。表面的には、Wireは重複を許可できますが、これはいくつかの意図しない結果をもたらします:

-  Wireは、どのような種類の重複が許容されるかを指定する必要があります: 2つの`wire.Value`呼び出しは「同じ」と見なされることがありますか?
-  プロバイダセットが型を提供するために使用する関数を変更した場合、「同じ」プロバイダを指定していた別のプロバイダセットとの間に新しい競合が導入される可能性があるため、これはアプリケーションを壊す可能性があります。

そのため、このケースはエラーとするのがより単純な動作であると判断しました。この制限は後でいつでも緩和できることを知っています。ユーザーは競合する型を持たない新しいプロバイダセットをいつでも作成できます。[提案されているsubtractコマンド][]は、このプロセスの手間を自動化します。

[提案されているsubtractコマンド]: https://github.com/google/wire/issues/8

## なぜWireは型がインターフェース型を提供することを明示的に宣言する必要があるのですか?

バインディングが明示的である理由は、同じインターフェースを実装する新しい型をプロバイダグラフに追加すると、グラフが壊れるというシナリオを避けるためです。これは驚くべきことです。これにより、より多くのタイピングが必要になりますが、最終的な効果は、開発者の意図がコードでより明示的になることです。これがGo哲学と最も一貫性があると感じました。

これを改善することを検討する[オープンイシュー](https://github.com/google/wire/issues/242)があります。

## 小規模なアプリケーションにWireを使用すべきですか?

おそらくそうではありません。Wireは、大規模なアプリケーションで見られるより複雑なセットアップコードを自動化するように設計されています。小規模なアプリケーションの場合、依存関係を手動で配線する方が簡単です。

## 誰がWireを使用していますか?

Wireはまだかなり新しく、大きなユーザーベースはありません。しかし、アプリケーションを簡素化したいGoユーザーから多くの関心を聞いています。あなたのプロジェクトや会社がWireを使用している場合は、メールを送信するか、このセクションを修正するプルリクエストを送信してお知らせください。
